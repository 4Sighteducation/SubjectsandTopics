1. Content of Algorithms and programming (Component 02)
   1.1 Elements of computational thinking
      1.1.1 Thinking abstractly
         1.1.1.1 The nature of abstraction.
         1.1.1.2 The need for abstraction.
         1.1.1.3 The differences between an abstraction and reality.
         1.1.1.4 Devise an abstract model for a variety of situations.
      1.1.2 Thinking ahead
         1.1.2.1 Identify the inputs and outputs for a given situation.
         1.1.2.2 Determine the preconditions for devising a solution to a problem.
         1.1.2.3 The nature, benefits and drawbacks of caching.
         1.1.2.4 The need for reusable program components.
      1.1.3 Thinking procedurally
         1.1.3.1 Identify the components of a problem.
         1.1.3.2 Identify the components of a solution to a problem.
         1.1.3.3 Determine the order of the steps needed to solve a problem.
         1.1.3.4 Identify sub-procedures necessary to solve a problem.
      1.1.4 Thinking logically
         1.1.4.1 Identify the points in a solution where a decision has to be taken.
         1.1.4.2 Determine the logical conditions that affect the outcome of a decision.
         1.1.4.3 Determine how decisions affect flow through a program.
      1.1.5 Thinking concurrently
         1.1.5.1 Determine the parts of a problem that can be tackled at the same time.
         1.1.5.2 Outline the benefits and trade-offs that might result from concurrent processing in a particular situation.
   1.2 Problem solving and programming
      1.2.1 Programming techniques
         1.2.1.1 Programming constructs: sequence, iteration, branching.
         1.2.1.2 Recursion, how it can be used and compares to an iterative approach.
         1.2.1.3 Global and local variables.
         1.2.1.4 Modularity, functions and procedures, parameter passing by value and by reference.
         1.2.1.5 Use of an IDE to develop/debug a program.
         1.2.1.6 Use of object-oriented techniques.
      1.2.2 Computational methods
         1.2.2.1 Features that make a problem solvable by computational methods.
         1.2.2.2 Problem recognition.
         1.2.2.3 Problem decomposition.
         1.2.2.4 Use of divide and conquer.
         1.2.2.5 Use of abstraction.
         1.2.2.6 Learners should apply their knowledge of backtracking, data mining, heuristics, performance modelling, pipelining, and visualisation to solve problems.
   1.3 Algorithms
      1.3.1 Algorithms
         1.3.1.1 Analysis and design of algorithms for a given situation.
         1.3.1.2 The suitability of different algorithms for a given task and data set, in terms of execution time and space.
         1.3.1.3 Measures and methods to determine the efficiency of different algorithms, Big O notation (constant, linear, polynomial, exponential and logarithmic complexity).
         1.3.1.4 Comparison of the complexity of algorithms.
         1.3.1.5 Algorithms for the main data structures, (stacks, queues, trees, linked lists, depth-first (post-order) and breadth-first traversal of trees).
         1.3.1.6 Standard algorithms (bubble sort, insertion sort, merge sort, quick sort, Dijkstraâ€™s shortest path algorithm, A* algorithm, binary search and linear search).

2. Content of non-exam assessment Programming project (Component 03 or 04)
   2.1 Analysis of the problem
   2.2 Design of the solution
   2.3 Developing the solution
   2.4 Evaluation