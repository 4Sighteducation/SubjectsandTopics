# Repo tidy write-up (2026-01-01)

This document records the repository hygiene work carried out on **2026-01-01** across the three repos that make up the FLASH product:

- `FLASH` (main app)
- `FLASH_marketing` (marketing + checkout site)
- `flash-curriculum-pipeline` (scraping + content pipeline)

The intent was to eliminate “mystery state” (hidden changes not visible in `git status`), preserve all WIP safely, and ensure that **builds are reproducible from clean commits**.

---

## Why we did this

We had a production/testing incident where:

- The **dev build** appeared to have Subject Page changes
- But the **iOS build** did not reflect them reliably

The underlying risk pattern was:

- There were **large amounts of local, uncommitted, and/or hidden changes**.
- Critical work existed in **stashes** or local-only state.
- Some files were effectively “hidden from normal workflows” (notably via index flags and stash usage).

This tidy work makes it much harder for “tested locally but not shipped” to occur.

---

## Full safety backups created (filesystem-level)

Before changing anything, we created timestamped tarball backups of all three repo directories:

- **Backup folder**: `Apps/backups/20260101-222409/`
- **Files**:
  - `FLASH.tar.gz`
  - `FLASH_marketing.tar.gz`
  - `flash-curriculum-pipeline.tar.gz`

Notes:

- Backups excluded obvious heavy/generated paths (`node_modules/`, `.tmp/`, `.next/`, `dist/`, `poppler/`, etc.) to keep the archive reasonably sized.
- These backups allow full restore even if git metadata or local branches become confused.

---

## FLASH (main app) — changes performed

### 1) Created a WIP snapshot branch of the **entire dirty working tree**

We took whatever was currently in the working tree (including untracked files) and committed it into a WIP branch:

- **Branch**: `wip/20260101-222942-pre-tidy`
- **Purpose**: “point-in-time snapshot” of the entire local state before cleanup.

### 2) Reset `main` back to a clean, build-safe baseline

After snapshotting, we returned `main` to match remote and cleaned untracked files:

- `git fetch origin`
- `git reset --hard origin/main`
- `git clean -fd`

Result:

- `main` became **clean** (`git status` empty) and safe for reproducible builds.

### 3) Converted all stashes into named WIP branches (no more stash black boxes)

`FLASH` had 4 stashes. Each stash was converted into its own branch using `git stash branch ...`, then committed so it can be reviewed/merged/cherry-picked normally:

- `wip/stash-0-parent-claim`
- `wip/stash-1-clutter`
- `wip/stash-2-onboarding-track-cleanup`
- `wip/stash-3-android-compilesdk35`

After conversion:

- `git stash list` is empty
- Nothing is “trapped” in stash format

### 4) Pushed all WIP branches to GitHub (remote backup)

All WIP branches were pushed upstream so recovery does not depend on this machine:

- `wip/20260101-222942-pre-tidy`
- `wip/stash-0-parent-claim`
- `wip/stash-1-clutter`
- `wip/stash-2-onboarding-track-cleanup`
- `wip/stash-3-android-compilesdk35`

### 5) End state of FLASH

- `main` is clean and matches `origin/main`
- No stashes remain
- All prior local WIP is preserved as named branches (and pushed)

---

## FLASH_marketing — changes performed

### 1) Created and pushed a WIP snapshot branch

- **Branch**: `wip/20260101-223140-pre-tidy`
- Includes the entire local dirty working tree at the time.

### 2) Reset `main` to clean baseline

- `git fetch origin`
- `git reset --hard origin/main`
- `git clean -fd`

### 3) End state of FLASH_marketing

- `main` is clean and matches `origin/main`
- WIP snapshot branch exists and is pushed

---

## flash-curriculum-pipeline — changes performed

This repo is expected to be “noisy” because scraping and outputs churn frequently. The priority was to prevent accidental commits of huge/temporary artifacts.

### 1) Fixed and strengthened `.gitignore`

Changes included:

- Fixed a typo where `geckodriver` and `node_modules` had accidentally merged into one ignore entry.
- Added ignores for:
  - `node_modules/`
  - `.tmp/`, `tmp/`, `temp/`
  - `poppler/`, `poppler.zip`
  - report/debug outputs (`data/reports/`, `data/assessment_resources/`, `debug*.{txt,md,html}`, etc.)

### 2) Committed and pushed `.gitignore` change

- Commit message: `chore: ignore node_modules/temp/debug outputs`
- Commit: `cc4f815`

### 3) End state of flash-curriculum-pipeline

- Repo can remain dirty by design (ongoing scraping work)
- Git is less likely to surface massive output artifacts as changes

---

## Notes on “skip-worktree” vs “assume-unchanged”

During investigation we saw many files prefixed with `H` in `git ls-files -v`.

- In standard git tooling, `S` indicates `skip-worktree`, and `H` is often used to indicate `assume-unchanged` / “hidden” behavior.
- Regardless of the exact mechanism, the symptom is the same: **changes may not show up in `git status`**.

Instead of relying on these flags for day-to-day work, the new approach is:

- keep `main` clean
- capture WIP in WIP branches
- ignore truly local/generated paths via `.gitignore`

---

## Future improvement (not implemented yet)

To make this foolproof, add a small guard to the main app repo that refuses to run production build commands when the working tree is dirty:

- **Example**: a script `scripts/require-clean-git.sh` that fails if `git status --porcelain` is non-empty.
- Then wire it into `npm run build:ios` / `npm run build:android`:
  - run the guard script first
  - only then invoke `eas build ...`

This prevents “I built from uncommitted local changes” from ever happening again.

---

## How to recover anything (quick reference)

- **Restore from WIP branches**:
  - checkout a WIP branch and cherry-pick/merge into a feature branch
- **Restore from tar.gz backups**:
  - extract the relevant archive in `Apps/backups/20260101-222409/`
  - copy files back into place if needed

